# qstring
# More usefull stuff for Qt by KDE at http://websvn.kde.org/trunk/KDE/kdesdk/scripts/kde-devel-gdb
define printqstring
    printf "(QString)0x%x (length=%i): \"",&$arg0,$arg0.d->size
    set $i=0
    while $i < $arg0.d->size
        set $c=$arg0.d->data[$i++]
        if $c < 32 || $c > 127
                printf "\\u0x%04x", $c
        else
                printf "%c", (char)$c
        end
    end
    printf "\"\n"
end

# https://github.com/ellzey/dotfiles/blob/master/gdbinit
define dumptailq
	set $tailq_head = $arg0
	set $ent        = (($tailq_head)->tqh_first)

	while ($ent != (void *)0l)
		print *$ent
		set $ent = ($ent)->next.tqe_next
	end
end
document dumptailq
	Print a sys/queue.h TAILQ structure, assumes TAILQ_ENTRY is next
	Usage: dumptailq tailq head
end

define dump_zt_table
	set $table_addr = $arg0
	set $name = (char *)(*$table_addr)

	printf "tbl start addr = %p\n", $table_addr
  printf "tbl name       = %s\n", $name
end

define dump_apr_lua_stack
	set $i       = 1
	set $lua_top = lua_gettop($arg0)

	while $i <= $lua_top
		set $typename = "nil"
		set $t = lua_type($arg0, $i)

		if $t == 0
			set $typename = "nil"
		end

		if $t == 1
			set $typename = "bool"
		end

		if $t == 2
			set $typename = "listuser"
		end

		if $t == 3
			set $typename = "number"
		end

		if $t == 4
			set $typename = "string"
		end

		if $t == 5
			set $typename = "table"
		end

		if $t == 6
			set $typename = "function"
		end

		if $t == 7
			set $typename = "userdata"
		end

		if $t == 8
			set $typename = "thread"
		end


		printf "[%d] = %d (%s)\n", $i, lua_type($arg0, $i), $typename
		set $i = $i + 1
	end
end


define dump_apr_table
    set $t = (apr_table_entry_t *)((apr_array_header_t *)$arg0)->elts
    set $n = ((apr_array_header_t *)$arg0)->nelts
    set $i = 0
    while $i < $n
	if $t[$i].val == (void *)0L
	   printf "[%u] '%s'=>NULL\n", $i, $t[$i].key
	else
	   printf "[%u] '%s'='%s'\n", $i, $t[$i].key, $t[$i].val
	end
	set $i = $i + 1
    end
end
document dump_apr_table
    Print the key/value pairs in a table.
end

define dump_apr_string_array
    set $a = (char **)((apr_array_header_t *)$arg0)->elts
    set $n = (int)((apr_array_header_t *)$arg0)->nelts
    set $i = 0
    while $i < $n
	printf "[%u] '%s'\n", $i, $a[$i]
	set $i = $i + 1
    end
end
document dump_apr_string_array
    Print all of the elements in an array of strings.
end

define printmemn
    set $i = 0
    while $i < $arg1
        if $arg0[$i] < 0x20 || $arg0[$i] > 0x7e
            printf "~"
        else
            printf "%c", $arg0[$i]
        end
        set $i = $i + 1
    end
end

define print_bkt_datacol
    # arg0 == column name
    # arg1 == format
    # arg2 == value
    # arg3 == suppress header?
    set $suppressheader = $arg3

    if !$suppressheader
        printf " "
        printf $arg0
        printf "="
    else
        printf " | "
    end
    printf $arg1, $arg2
end

define dump_apr_bucket_ex
    # arg0 == bucket
    # arg1 == suppress header?
    set $bucket = (struct apr_bucket *)$arg0
    set $sh = $arg1
    set $refcount = -1

    print_bkt_datacol "bucket" "%-9s" $bucket->type->name $sh
    printf "(0x%08lx)", (unsigned long)$bucket
    print_bkt_datacol "length" "%-6ld" (long)($bucket->length) $sh
    print_bkt_datacol "data" "0x%08lx" $bucket->data $sh

    if !$sh
        printf "\n    "
    end

    if (($bucket->type == &apr_bucket_type_eos)   || \
        ($bucket->type == &apr_bucket_type_flush))

        # metadata buckets, no content
        print_bkt_datacol "contents" "%c" ' ' $sh
        printf "                     "
        print_bkt_datacol "rc" "n/%c" 'a' $sh

    else
    if ($bucket->type == &ap_bucket_type_error)

        # metadata bucket, no content but it does have an error code in it
        print_bkt_datacol "contents" "%c" ' ' $sh
        set $status = ((ap_bucket_error *)$bucket->data)->status
        printf " (status=%3d)        ", $status
        print_bkt_datacol "rc" "n/%c" 'a' $sh

    else
    if (($bucket->type == &apr_bucket_type_file) || \
        ($bucket->type == &apr_bucket_type_pipe) || \
        ($bucket->type == &apr_bucket_type_socket))

        # buckets that contain data not in memory (ie not printable)

        print_bkt_datacol "contents" "[**unprintable**%c" ']' $sh
        printf "     "
        if $bucket->type == &apr_bucket_type_file
            set $refcount = ((apr_bucket_refcount *)$bucket->data)->refcount
            print_bkt_datacol "rc" "%d" $refcount $sh
        end

    else
    if (($bucket->type == &apr_bucket_type_heap)      || \
        ($bucket->type == &apr_bucket_type_pool)      || \
        ($bucket->type == &apr_bucket_type_mmap)      || \
        ($bucket->type == &apr_bucket_type_transient) || \
        ($bucket->type == &apr_bucket_type_immortal))

        # in-memory buckets

        if $bucket->type == &apr_bucket_type_heap
            set $refcount = ((apr_bucket_refcount *)$bucket->data)->refcount
            set $p = (apr_bucket_heap *)$bucket->data
            set $data = $p->base+$bucket->start

        else
        if $bucket->type == &apr_bucket_type_pool
            set $refcount = ((apr_bucket_refcount *)$bucket->data)->refcount
            set $p = (apr_bucket_pool *)$bucket->data
            if !$p->pool
                set $p = (apr_bucket_heap *)$bucket->data
            end
            set $data = $p->base+$bucket->start

        else
        if $bucket->type == &apr_bucket_type_mmap
            # is this safe if not APR_HAS_MMAP?
            set $refcount = ((apr_bucket_refcount *)$bucket->data)->refcount
            set $p = (apr_bucket_mmap *)$bucket->data
            set $data = ((char *)$p->mmap->mm)+$bucket->start

        else
        if (($bucket->type == &apr_bucket_type_transient) || \
            ($bucket->type == &apr_bucket_type_immortal))
            set $data = ((char *)$bucket->data)+$bucket->start

        end
        end
        end
        end

        if $sh
            printf " | ["
        else
            printf " contents=["
        end
        set $datalen = $bucket->length
        if $datalen > 17
            printmem $data 17
            printf "..."
            set $datalen = 20
        else
            printmemn $data $datalen
        end
        printf "]"
        while $datalen < 20
            printf " "
            set $datalen = $datalen + 1
        end

        if $refcount != -1
            print_bkt_datacol "rc" "%d" $refcount $sh
        else
            print_bkt_datacol "rc" "n/%c" 'a' $sh
        end

    else
        # 3rd-party bucket type
        print_bkt_datacol "contents" "[**unknown**%c" ']' $sh
        printf "         "
        print_bkt_datacol "rc" "n/%c" 'a' $sh
    end
    end
    end
    end

    printf "\n"

end

define dump_apr_bucket
    dump_apr_bucket_ex $arg0 0
end
document dump_apr_bucket
    Print bucket info
end

define dump_apr_brigade
    set $bb = (apr_bucket_brigade *)$arg0
    set $bucket = $bb->list.next
    set $sentinel = ((char *)((&($bb->list)) \
                               - ((size_t) &((struct apr_bucket *)0)->link)))
    printf "dump of brigade 0x%lx\n", (unsigned long)$bb

    printf "   | type     (address)    | length | "
    printf "data addr  | contents               | rc\n"
    printf "----------------------------------------"
    printf "----------------------------------------\n"

    if $bucket == $sentinel
        printf "brigade is empty\n"
    end

    set $j = 0
    while $bucket != $sentinel
        printf "%2d", $j
        dump_apr_bucket_ex $bucket 1
        set $j = $j + 1
        set $bucket = $bucket->link.next
    end
    printf "end of brigade\n"
end
document dump_apr_brigade
    Print bucket brigade info
end

define dump_apr_filters
    set $f = $arg0
    while $f
        printf "%s(0x%lx): ctx=0x%lx, r=0x%lx, c=0x%lx\n", \
        $f->frec->name, (unsigned long)$f, (unsigned long)$f->ctx, \
        $f->r, $f->c
        set $f = $f->next
    end
end
document dump_apr_filters
    Print filter chain info
end

define dump_apr_process_rec
    set $p = $arg0
    printf "process_rec=0x%lx:\n", (unsigned long)$p
    printf "   pool=0x%lx, pconf=0x%lx\n", \
           (unsigned long)$p->pool, (unsigned long)$p->pconf
end
document dump_apr_process_rec
    Print process_rec info
end

define dump_apr_server_rec
    set $s = $arg0
    printf "name=%s:%d\n", \
            $s->server_hostname, $s->port
    dump_apr_process_rec($s->process)
end
document dump_apr_server_rec
    Print server_rec info
end

define dump_apr_servers
    set $s = $arg0
    while $s
        dump_apr_server_rec($s)
        printf "\n"
        set $s = $s->next
    end
end
document dump_apr_servers
    Print server_rec list info
end

define tbt
	thread apply all bt
end
document tbt
	Print backtrace of all running threads
end
